// Generated by CoffeeScript 1.3.1
var bomb_collision, bombs, check_collisions, drop_bomb, explode_bomb, explosion, explosions, extinguish_explosion, game_logic, game_over_screen, game_started, init_game, intro_screen, player_collision, players, shake_map, timer, update_map;

players = new Array();

bombs = new Array();

explosions = new Array();

timer = null;

game_started = false;

intro_screen = function() {
  return $('#map').drawText({
    fillStyle: '#000',
    x: 250,
    y: 100,
    text: 'JSBomber',
    font: '60pt Helvetica, sans-serif'
  }).drawText({
    fillStyle: '#000',
    x: 250,
    y: 300,
    text: "Press 'spacebar' to continue",
    font: '25pt Helvetica, sans-serif'
  });
};

game_over_screen = function(text) {
  return $('#map').drawText({
    fillStyle: '#000',
    x: 250,
    y: 100,
    text: text,
    font: '50pt Helvetica, sans-serif'
  }).drawText({
    fillStyle: '#000',
    x: 250,
    y: 300,
    text: "Play again? (Spacebar)",
    font: '25pt Helvetica, sans-serif'
  });
};

init_game = function() {
  game_started = true;
  players[0] = {
    position: {
      x: 25,
      y: 25
    },
    speed: 5,
    num_bombs: 3,
    bomb_range: 1,
    controls: {
      up: 87,
      down: 83,
      left: 65,
      right: 68,
      drop: 88
    },
    up: false,
    down: false,
    right: false,
    left: false,
    dead: false
  };
  return players[1] = {
    position: {
      x: 475,
      y: 475
    },
    speed: 5,
    num_bombs: 3,
    bomb_range: 1,
    controls: {
      up: 80,
      down: 186,
      left: 76,
      right: 222,
      drop: 191
    },
    up: false,
    down: false,
    right: false,
    left: false,
    dead: false
  };
};

game_logic = function() {
  var player, _i, _len;
  for (_i = 0, _len = players.length; _i < _len; _i++) {
    player = players[_i];
    if (player.up) {
      player.position.y -= player.speed;
    } else if (player.down) {
      player.position.y += player.speed;
    } else if (player.left) {
      player.position.x -= player.speed;
    } else if (player.right) {
      player.position.x += player.speed;
    }
    if (player.position.y < 25 / 2) {
      player.position.y = 25 / 2;
    } else if (player.position.y > 475 + 25 / 2) {
      player.position.y = 475 + 25 / 2;
    }
    if (player.position.x < 25 / 2) {
      player.position.x = 25 / 2;
    } else if (player.position.x > 475 + 25 / 2) {
      player.position.x = 475 + 25 / 2;
    }
  }
  update_map();
  if (check_collisions()) {
    clearTimeout(timer);
    return game_started = false;
  } else {
    return timer = setTimeout("game_logic()", 25);
  }
};

update_map = function() {
  var elem, player, _i, _j, _k, _len, _len1, _len2, _results;
  $('#map').clearCanvas();
  for (_i = 0, _len = bombs.length; _i < _len; _i++) {
    elem = bombs[_i];
    $('#map').drawRect({
      fillStyle: '#0c9df9',
      x: elem.x,
      y: elem.y,
      width: 40,
      height: 40,
      fromCenter: true
    });
  }
  for (_j = 0, _len1 = explosions.length; _j < _len1; _j++) {
    elem = explosions[_j];
    $('#map').drawLine({
      strokeStyle: "#f90c22",
      strokeWidth: 2,
      x1: elem.x,
      y1: elem.y - elem.r * 50,
      x2: elem.x,
      y2: elem.y + elem.r * 50
    }).drawLine({
      strokeStyle: "#f90c22",
      strokeWidth: 2,
      x1: elem.x - elem.r * 50,
      y1: elem.y,
      x2: elem.x + elem.r * 50,
      y2: elem.y
    });
  }
  _results = [];
  for (_k = 0, _len2 = players.length; _k < _len2; _k++) {
    player = players[_k];
    _results.push($('#map').drawRect({
      fillStyle: '#3d454b',
      x: player.position.x,
      y: player.position.y,
      width: 25,
      height: 25,
      fromCenter: true,
      strokeStyle: '#000',
      strokeWidth: 1
    }));
  }
  return _results;
};

drop_bomb = function(x_pos, y_pos, pid, brange) {
  return bombs.push({
    x: x_pos,
    y: y_pos,
    player_id: pid,
    range: brange,
    timer: setTimeout("explode_bomb()", 3000)
  });
};

explode_bomb = function(index) {
  var pid;
  if (index == null) {
    index = 0;
  }
  clearTimeout(bombs[index].timer);
  pid = bombs[index].player_id;
  players[pid].num_bombs += 1;
  explosion(bombs[index].x, bombs[index].y, bombs[index].range);
  return bombs.splice(index, 1);
};

explosion = function(x_pos, y_pos, range) {
  shake_map(range);
  explosions.push({
    x: x_pos,
    y: y_pos,
    r: range
  });
  return setTimeout("extinguish_explosion()", 1000);
};

extinguish_explosion = function() {
  return explosions.splice(0, 1);
};

check_collisions = function() {
  var explosion, player, _i, _j, _len, _len1;
  for (_i = 0, _len = explosions.length; _i < _len; _i++) {
    explosion = explosions[_i];
    for (_j = 0, _len1 = players.length; _j < _len1; _j++) {
      player = players[_j];
      if (player_collision(player, explosion)) {
        player.dead = true;
      }
    }
  }
  if (players[0].dead && players[1].dead) {
    game_over_screen('double suicide');
    return true;
  } else if (players[0].dead) {
    game_over_screen('player 1 dead');
    return true;
  } else if (players[1].dead) {
    game_over_screen('player 2 dead');
    return true;
  } else {
    return false;
  }
};

player_collision = function(player, explosion) {
  var _ref, _ref1;
  if (((player.position.x - 25 / 2 < (_ref = explosion.x) && _ref < player.position.x + 25 / 2) && Math.abs(player.position.y - explosion.y) < explosion.r * 50) || ((player.position.y - 25 / 2 < (_ref1 = explosion.y) && _ref1 < player.position.y + 25 / 2) && Math.abs(player.position.x - explosion.x) < explosion.r * 50)) {
    return true;
  } else {
    return false;
  }
};

bomb_collision = function(bomb, explosion) {
  var _ref, _ref1;
  if ((bomb.x - 40 / 2 < (_ref = explosion.x) && _ref < bomb.x + 40 / 2) || (bomb.y - 40 / 2 < (_ref1 = explosion.y) && _ref1 < bomb.y + 40 / 2)) {
    return true;
  } else {
    return false;
  }
};

shake_map = function(offset) {
  return $('#map').animate({
    left: '+=' + offset
  }, 100, function() {
    return $('#map').animate({
      left: '-=' + offset
    }, 100, function() {});
  });
};

$(function() {
  return intro_screen();
});

$(document).bind('keydown', function(e) {
  var player, player_id, _i, _len;
  if (!event.metaKey) {
    if (!game_started) {
      if (e.which === 32) {
        init_game();
        game_logic();
      }
    }
    for (player_id = _i = 0, _len = players.length; _i < _len; player_id = ++_i) {
      player = players[player_id];
      if (e.which === player.controls.up) {
        player.up = true;
      } else if (e.which === player.controls.down) {
        player.down = true;
      } else if (e.which === player.controls.left) {
        player.left = true;
      } else if (e.which === player.controls.right) {
        player.right = true;
      } else if (e.which === player.controls.drop) {
        if (player.num_bombs > 0) {
          drop_bomb(player.position.x, player.position.y, player_id, player.bomb_range);
          player.num_bombs -= 1;
        }
      }
    }
    return false;
  }
}).bind('keyup', function(e) {
  var player, player_id, _i, _len;
  if (!event.metaKey) {
    for (player_id = _i = 0, _len = players.length; _i < _len; player_id = ++_i) {
      player = players[player_id];
      if (e.which === player.controls.up) {
        player.up = false;
      } else if (e.which === player.controls.down) {
        player.down = false;
      } else if (e.which === player.controls.left) {
        player.left = false;
      } else if (e.which === player.controls.right) {
        player.right = false;
      }
    }
    return false;
  }
});
